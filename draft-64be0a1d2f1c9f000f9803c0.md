---
title: "Migrating your classic Single Page Application to AWS. Part 1."
slug: migrating-your-classic-single-page-application-to-aws-part-1
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1690176543999/289fa3cc-d809-4355-8b59-9491076c64ec.png

---

Now you have containers, how to ship them? Evaluating AWS App Runner, ECS, and EKS on Fargate for a Classic Single-Page App

# Introduction

As with any IT solution generic discussions about where to run your containers may always come to the same answer "It depends". It depends on the size, it depends on the skill set, it depends on time budget etc. In this article, I want to focus on the specific use case of migrating production on-prem web applications to the cloud.

# Interesting part

A big part of this series is also to gather the pros and cons of five options to host your Backend. The options are:

1. **EC2** (Elastic Compute Cloud): Amazon EC2 is a web service that provides resizable computing capacity in the cloud. It allows users to launch and manage virtual machines, known as instances, on the AWS cloud infrastructure. EC2 offers flexibility in selecting instance types, operating systems, and security configurations, making it a popular choice for running a wide range of applications.
    
2. **AppRunner**: AWS AppRunner is a fully managed service that simplifies containerized application deployment. With AppRunner, developers can quickly build, deploy, and scale applications without manual configurations. It automatically handles tasks like capacity provisioning, load balancing, and scaling, enabling developers to focus on writing code and accelerating their development workflows.
    
3. **ECS** (Elastic Container Service): Amazon ECS is a scalable container orchestration service designed to manage Docker containers. It allows users to run quickly and scale containerized applications on a cluster of EC2 instances or AWS Fargate, a serverless compute engine for containers. ECS simplifies container deployment, load balancing, and monitoring, making it an ideal choice for containerized application environments.
    
4. **EKS** (Elastic Kubernetes Service): Amazon EKS is a fully managed Kubernetes service that makes running, managing, and scaling containerized applications easier using Kubernetes on AWS. EKS eliminates the need for managing Kubernetes control plane infrastructure, providing a highly available and secure platform for deploying containerized workloads. It offers seamless integration with other AWS services and allows users to focus on building applications rather than managing Kubernetes infrastructure.
    
5. **Lambdas / Serverless** (AWS Lambda): AWS Lambda is a serverless computing service that enables developers to run code without provisioning or managing servers. With Lambda, users can upload their code, and it automatically handles the execution based on incoming events or triggers. It scales automatically, responding to demand, and users only pay for the compute time consumed by their functions. This serverless approach simplifies application development and reduces operational overhead, allowing developers to build event-driven, scalable applications easily.
    

# Use case

This imaginary application is a [Single Page Application (SPA)](https://developer.mozilla.org/en-US/docs/Glossary/SPA) with a backend. Our app is a classic three-layered architecture. To work with a "real" application I'll use a combination of HTML files as a Frontend and for the Backend I'll stick to [Spring Boot Tutorial app](https://github.com/spring-guides/gs-rest-service/tree/main/complete). All code and different interactions are available in my git repository \[TODO add link\].

I'm talking about interactions because we will migrate SPA in the next steps:

1. Host our static assets with Cloudfront and S3. At this point, our goal is to get our Frontend running on a publically available httpS URL.
    
2. The next step is to get an independent URL for our Backend and test it successfully.
    
3. Then we will connect our Backend URL on /api path to the main Frontend URL to enable AJAX calls.
    
4. The last step is to add Sign In functionality and protect our Backend URL with the JWT Authorization header. This means that Backend API will reject all requests without valid JWT included in the Authorization header.
    

Please check Figure 1. and Figure 2 for the whole architecture and interaction.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1690450254336/a3122293-49ac-4088-881a-3c4f703a98cd.png align="center")

Figure 1. Generic Architecture to deploy our SPA to AWS

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1690450390933/1f1e9e26-b5c2-4470-93d6-95d9d5e97bd7.png align="center")

Figure 2. Sequence diagram of interactions between moving parts

# Summary

This part describes the use case and possible five architecture variations for porting Single Page Applications to the Cloud.